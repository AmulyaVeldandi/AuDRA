"""Construct FHIR ServiceRequest payloads."""

from __future__ import annotations

import json
from datetime import date, datetime, timezone
from typing import Any, Dict, List, Optional

from src.tasks.generator import Task

try:  # pragma: no cover - optional dependency
    from fhir.resources.fhirabstractbase import FHIRValidationError
    from fhir.resources.servicerequest import ServiceRequest as FHIRServiceRequest
except ImportError:  # pragma: no cover - library not present
    FHIRServiceRequest = None
    FHIRValidationError = Exception


class FHIRServiceRequestBuilder:
    """Create validated FHIR R4 ServiceRequest resources from internal tasks."""

    _SYSTEM_MAP = {
        "CPT": "http://www.ama-assn.org/go/cpt",
        "LOINC": "http://loinc.org",
        "CUSTOM": "http://audra-rad.com/codes/custom",
    }

    def build_service_request(
        self,
        task: Task,
        diagnostic_report_id: str,
        practitioner_id: str = "Practitioner/audra-system",
    ) -> Dict[str, Any]:
        """Build a FHIR R4 ServiceRequest payload from a Task."""

        if not isinstance(task, Task):
            raise TypeError("Task parameter must be an instance of Task.")
        if not diagnostic_report_id:
            raise ValueError("Diagnostic report identifier is required.")

        timeframe = self._extract_timeframe(task)
        occurrence_timing = self.build_timing(task.scheduled_date, timeframe)

        resource: Dict[str, Any] = {
            "resourceType": "ServiceRequest",
            "id": task.task_id,
            "status": "active",
            "intent": "order",
            "priority": task.priority,
            "code": {
                "coding": self._build_coding(task.procedure_code),
                "text": task.procedure_name,
            },
            "subject": {"reference": self._ensure_reference("Patient", task.patient_id)},
            "occurrenceTiming": occurrence_timing,
            "authoredOn": datetime.now(timezone.utc).isoformat(),
            "requester": {
                "reference": practitioner_id,
                "display": task.ordering_provider or "AuDRA-Rad System",
            },
            "reasonReference": [
                {"reference": self._ensure_reference("DiagnosticReport", diagnostic_report_id)}
            ],
            "note": [{"text": task.clinical_reason}],
            "meta": {
                "tag": [
                    {
                        "system": "http://audra-rad.com/tags",
                        "code": "automated-followup",
                        "display": "Generated by AuDRA-Rad",
                    }
                ]
            },
        }

        if task.metadata:
            resource.setdefault("extension", []).append(
                {
                    "url": "http://audra-rad.com/StructureDefinition/task-metadata",
                    "valueString": json.dumps(task.metadata, default=str),
                }
            )

        self.validate_service_request(resource)
        return resource

    # ------------------------------------------------------------------ #
    def validate_service_request(self, fhir_json: Dict[str, Any]) -> bool:
        """Validate a FHIR ServiceRequest payload."""

        required_top_level = ["resourceType", "status", "intent", "code", "subject"]
        for field in required_top_level:
            if field not in fhir_json or not fhir_json[field]:
                raise ValueError(f"Field '{field}' is required for ServiceRequest.")

        if fhir_json["resourceType"] != "ServiceRequest":
            raise ValueError("resourceType must be 'ServiceRequest'.")

        if fhir_json["status"] not in {"active", "draft"}:
            raise ValueError("ServiceRequest.status must be 'active' or 'draft'.")

        if fhir_json["intent"] not in {"order", "plan"}:
            raise ValueError("ServiceRequest.intent must be 'order' or 'plan'.")

        subject_reference = fhir_json["subject"].get("reference")
        if not subject_reference:
            raise ValueError("ServiceRequest.subject.reference is required.")

        coding = fhir_json["code"].get("coding")
        if not coding or not isinstance(coding, list):
            raise ValueError("ServiceRequest.code.coding must be a non-empty list.")

        primary = coding[0]
        if "system" not in primary or "code" not in primary:
            raise ValueError("Primary coding entry must include 'system' and 'code'.")

        if FHIRServiceRequest is not None:
            try:
                FHIRServiceRequest(**fhir_json)
            except FHIRValidationError as exc:  # pragma: no cover - optional dependency
                raise ValueError(f"FHIR resource validation failed: {exc}") from exc

        return True

    # ------------------------------------------------------------------ #
    def build_timing(self, scheduled_date: date, timeframe_months: Optional[int]) -> Dict[str, Any]:
        """Create a FHIR Timing object describing the intended schedule."""

        event_date = format_fhir_date(scheduled_date)

        months = timeframe_months if timeframe_months and timeframe_months > 0 else None
        if months is None:
            delta_days = max((scheduled_date - date.today()).days, 1)
            months = max(1, round(delta_days / 30))

        timing: Dict[str, Any] = {
            "event": [event_date],
            "repeat": {
                "boundsPeriod": {
                    "start": format_fhir_date(date.today()),
                    "end": event_date,
                },
                "frequency": 1,
                "period": months,
                "periodUnit": "mo",
            },
            "code": {"text": f"Scheduled in {months} month{'s' if months != 1 else ''}"},
        }
        return timing

    # ------------------------------------------------------------------ #
    # Internal helpers
    # ------------------------------------------------------------------ #

    def _build_coding(self, procedure_code: Dict[str, Any]) -> List[Dict[str, Any]]:
        primary = self._to_coding(procedure_code)
        alternates = procedure_code.get("alternate_codes") or []
        codings = [primary]
        for entry in alternates:
            codings.append(self._to_coding(entry))
        return codings

    def _to_coding(self, entry: Dict[str, Any]) -> Dict[str, Any]:
        if not isinstance(entry, dict):
            raise TypeError("Procedure coding entries must be dictionaries.")

        system = entry.get("system")
        code = entry.get("code")
        if not system or not code:
            raise ValueError("Procedure coding entry requires 'system' and 'code'.")

        system_uri = self._SYSTEM_MAP.get(system, f"http://audra-rad.com/codes/{system.lower()}")
        coding = {"system": system_uri, "code": code}
        if entry.get("display"):
            coding["display"] = entry["display"]
        return coding

    def _ensure_reference(self, resource_type: str, reference: str) -> str:
        if "/" in reference:
            return reference
        return f"{resource_type}/{reference}"

    def _extract_timeframe(self, task: Task) -> Optional[int]:
        recommendation = task.metadata.get("recommendation") if isinstance(task.metadata, dict) else None
        if isinstance(recommendation, dict):
            timeframe = recommendation.get("timeframe_months")
            if isinstance(timeframe, int):
                return timeframe
            try:
                return int(timeframe) if timeframe is not None else None
            except (TypeError, ValueError):
                return None
        return None

def format_fhir_date(dt: date) -> str:
    """Convert Python date to FHIR date format (YYYY-MM-DD)."""

    return dt.strftime("%Y-%m-%d")
